<h2>
    &nbsp;</h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    <b style="margin: 0px; padding: 0px;">Object-oriented programming</b>&nbsp;(OOP) is a programming paradigm that uses &quot;objects&quot; to design applications and computer programs. It utilizes several techniques from previously established paradigms, including inheritance, modularity, polymorphism, and encapsulation. Today, many popular programming languages (such as Ada, C++, Delphi,&nbsp;, Lisp, SmallTalk, Perl, PHP, Python, Ruby, VB.Net, Visual FoxPro, and Visual Prolog) support OOP.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    &nbsp;</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    Object-oriented programming&#39;s roots reach all the way back to the 1960s, when the nascent field of software engineering had begun to discuss the idea of a software crisis. As hardware and software became increasingly complex, how could software quality be maintained? Object-oriented programming addresses this problem by strongly emphasizing modularity in software.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    The Simula programming language was the first to introduce the concepts underlying object-oriented programming (objects, classes, subclasses, virtual methods, coroutines, garbage collection and discrete event simulation) as a superset of Algol. Smalltalk was the first programming language to be called &quot;object-oriented&quot;.</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    &nbsp;</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    Object-oriented programming may be seen as a collection of cooperating objects, as opposed to a traditional view in which a program may be seen as a list of instructions to the computer. In OOP, each object is capable of receiving messages, processing data, and sending messages to other objects. Each object can be viewed as an independent little machine with a distinct role or responsibility.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    Object-oriented programming came into existence because human consciousness, understanding and logic are highly object-oriented. By way of &quot;objectifying&quot; software modules, it is intended to promote greater flexibility and maintainability in programming, and is widely popular in large-scale software engineering. By virtue of its strong emphasis on modularity, object oriented code is intended to be simpler to develop and easier to understand later on, lending itself to more direct analysis, coding, and understanding of complex situations and procedures than less modular programming methods.</p>
<h3 style="margin: 1.2em 0px 0.3em; padding: 0px 0px 0.1em; font-family: arial; color: rgb(0, 0, 0); font-size: 16.7328px;">
    Fundamental concepts</h3>
<h2>
    &nbsp;</h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    &nbsp;</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    A survey of computing literature, identified a number of &quot;quarks,&quot; or fundamental concepts, identified in the strong majority of definitions of OOP. They are:<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Class</b><br style="margin: 0px; padding: 0px;" />
    A class defines the abstract characteristics of a thing (object), including the thing&#39;s characteristics (its attributes or properties) and the things it can do (its behaviors or methods or features). For example, the class Dog would consist of traits shared by all dogs, for example breed, fur color, and the ability to bark. Classes provide modularity and structure in an object-oriented computer program. A class should typically be recognizable to a non-programmer familiar with the problem domain, meaning that the characteristics of the class should make sense in context. Also, the code for a class should be relatively self-contained. Collectively, the properties and methods defined by a class are called members.<br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Object</b><br style="margin: 0px; padding: 0px;" />
    A particular instance of a class. The class of Dog defines all possible dogs by listing the characteristics that they can have; the object Lassie is one particular dog, with particular versions of the characteristics. A Dog has fur; Lassie has brown-and-white fur. In programmer jargon, the object Lassie is an instance of the Dog class. The set of values of the attributes of a particular object is called its state.<br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Method</b><br style="margin: 0px; padding: 0px;" />
    An object&#39;s abilities. Lassie, being a Dog, has the ability to bark. So bark() is one of Lassie&#39;s methods. She may have other methods as well, for example sit() or eat(). Within the program, using a method should only affect one particular object; all Dogs can bark, but you need one particular dog to do the barking.<br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Message passing</b><br style="margin: 0px; padding: 0px;" />
    &quot;The process by which an object sends data to another object or asks the other object to invoke a method.&quot;</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    &nbsp;</p>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    <b style="margin: 0px; padding: 0px;">Inheritance</b><br style="margin: 0px; padding: 0px;" />
    In some cases, a class will have &quot;subclasses,&quot; more specialized versions of a class. For example, the class Dog might have sub-classes called Collie, Chihuahua, and GoldenRetriever. In this case, Lassie would be an instance of the Collie subclass. Subclasses inherit attributes and behaviors from their parent classes, and can introduce their own. Suppose the Dog class defines a method called bark() and a property called furColor. Each of its sub-classes (Collie, Chihuahua, and GoldenRetriever) will inherit these members, meaning that the programmer only needs to write the code for them once. Each subclass can alter its inherited traits. So, for example, the Collie class might specify that the default furColor for a collie is brown-and-white. The Chihuahua subclass might specify that the bark() method is high-pitched by default. Subclasses can also add new members. The Chihuahua subclass could add a method called tremble(). So an individual chihuahua instance would use a high-pitched bark() from the Chihuahua subclass, which in turn inherited the usual bark() from Dog. The chihuahua object would also have the tremble() method, but Lassie would not, because she is a Collie, not a Chihuahua. In fact, inheritance is an &quot;is-a&quot; relationship: Lassie is a Collie. A Collie is a Dog. Thus, Lassie inherits the members of both Collies and Dogs. When an object or class inherits its traits from more than one ancestor class, and neither of these ancestors is an ancestor of the other, then it&#39;s called multiple inheritance.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Encapsulation</b><br style="margin: 0px; padding: 0px;" />
    Conceals the exact details of how a particular class works from objects that use its code or send messages to it. So, for example, the Dog class has a bark() method. The code for the bark() method defines exactly how a bark happens (e.g., by inhale() and then exhale(), at a particular pitch and volume). Timmy, Lassie&#39;s friend, however, does not need to know exactly how she barks. Encapsulation is achieved by specifying which classes may use the members of an object. The result is that each object exposes to any class a certain interface &mdash; those members accessible to that class. The reason for encapsulation is to prevent clients of an interface from depending on those parts of the implementation that are likely to change in future, thereby allowing those changes to be made more easily, that is, without changes to clients. For example, an interface can ensure that puppies can only be added to an object of the class Dog by code in that class. Members are often specified as public, protected or private, determining whether they are available to all classes, sub-classes or only the defining class. Some languages go further:&nbsp;uses the protected keyword to restrict access also to classes in the same package, and C++ allows one to specify which classes may access any member.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Abstraction</b><br style="margin: 0px; padding: 0px;" />
    Simplifying complex reality by modeling classes appropriate to the problem, and working at the most appropriate level of inheritance for a given aspect of the problem. For example, Lassie the Dog may be treated as a Dog much of the time, a Collie when necessary to access Collie-specific attributes or behaviors, and as an Animal (perhaps the parent class of Dog) when counting Timmy&#39;s pets.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Polymorphism</b><br style="margin: 0px; padding: 0px;" />
    Polymorphism is the ability of behavior to vary based on the conditions in which the behavior is invoked, that is, two or more methods, as well as operators (such as +, -, *, among others) can fit to many different conditions. For example, if a Dog is commanded to speak() this may elicit a Bark; if a Pig is commanded to speak() this may elicit an Oink. This is expected because Pig has a particular implementation inside the speak() method. The same happens to class Dog. Considering both of them inherit speak() from Animal, this is an example of Overriding Polymorphism. Another good example is about Overloading Polymorphism, a very common one considering operators, like &quot;+&quot;. Once defined an operator used to add numbers, given a class Number and also given two other classes that inherits from Number, such as Integer and Double. Any programmer expects to add two instances of Double or two instances of Integer in just the same way, and more than this: Any programmer expects the same behavior to any Number. In this case, the programmer must overload the concatenation operator, &quot;+&quot;, by making it able to operate with both Double and Integer instances. The way it is done varies a little bit from one language to another and must be studied in more details according to the programmer interest. Most of the OOP languages support small differences in method signatures as polymorphism. it&#39;s very useful, once it improves code readability, to enable implicit conversions to the correct handling method when apply add() method to integers, like in add(1,2), or to strings like in add(&quot;foo&quot;,&quot;bar&quot;) since the definitions of these signatures are available. In many OOP languages, such method signatures would be, respectively, very similar to add(int a, int b) and add(String a, String b). This is an example of Parametric Polymorphism. The returned type and used modifiers, of course, depend on the programmer interests and intentions.</p>
<h3 style="margin: 1.2em 0px 0.3em; padding: 0px 0px 0.1em; font-family: arial; color: rgb(0, 0, 0); font-size: 16.7328px;">
    History</h3>
<h2>
    &nbsp;</h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    The concept of objects and instances in computing had its first major breakthrough with the PDP-1 system at MIT which was the earliest example of capability based architecture. Another early example was Sketchpad made by Ivan Sutherland in 1963; however, this was an application and not a programming paradigm. Objects as programming entities were introduced in the 1960s in Simula 67, a programming language designed for making simulations, created by Ole-Johan Dahl and Kristen Nygaard of the Norwegian Computing Center in Oslo. Such an approach was a simple extrapolation of concepts earlier used in analog programming. On analog computers, such direct mapping from real-world phenomena/objects to analog phenomena/objects (and conversely), was (and is) called &#39;simulation&#39;. Simula not only introduced the notion of classes, but also of instances of classes, which is probably the first explicit use of those notions.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    The Smalltalk language, which was developed in the 1970s, introduced the term Object-oriented programming to represent the pervasive use of objects and messages as the basis for computation. Smalltalk creators were influenced by the ideas introduced in Simula 67, but Smalltalk was designed to be a fully dynamic system in which classes could be created and modified dynamically rather than simply using static ones. The ideas in Simula 67 were also used in many other languages, from derivatives of Lisp to Pascal.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    Object-oriented programming developed as the dominant programming methodology during the mid-1980s, largely due to the influence of C++. Its dominance was further cemented by the rising popularity of graphical user interfaces, for which object-oriented programming is well-suited. OOP toolkits also enhanced the popularity of &quot;event-driven programming&quot;. Some feel that association with GUIs (real or perceived) was what propelled OOP into the programming mainstream.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    OOP also became increasingly popular for developing computer games during the 1990s. As the complexity of games grew, as faster hardware became more widely available and compilers matured, more and more games and their engines were written in OOP languages. Since almost all video games feature virtual environments which contain many, often thousands of objects that interact with each other in complex ways, OOP languages are particularly suited for game development.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    Object-oriented features have been added to many existing languages during that time, including Ada, BASIC, Lisp, Fortran, Pascal, and others. Adding these features to languages that were not initially designed for them often led to problems with compatibility and maintainability of code.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    In the past decade Java has emerged in wide use partially because of its similarity to C++, but perhaps more importantly because of its implementation using a virtual machine that is intended to run code unchanged on many different platforms. This last feature has made it very attractive to larger development shops with heterogeneous environments. Microsoft&#39;s .NET initiative has a similar objective and includes/supports several new languages, or variants of older ones.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    Besides&nbsp;, probably the most commercially important recent object-oriented languages are Visual Basic .NET and C# designed for Microsoft&#39;s .NET platform.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    Just as procedural programming led to refinements of techniques such as structured programming, modern object-oriented software design methods include refinements such as the use of design patterns, design by contract, and modeling languages.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">OOP in scripting</b><br style="margin: 0px; padding: 0px;" />
    In recent years, object-oriented programming has become especially popular in scripting programming languages. Python and Ruby are scripting languages built on OOP principles, while Perl and PHP have been adding object oriented features since Perl 5 and PHP 4.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    The Document Object Model of&nbsp;, XHTML, and&nbsp;&nbsp;documents on the Internet have bindings to the popular JavaScript/ECMAScript language. JavaScript is perhaps the best known prototype-based programming language.</p>
<h3 style="margin: 1.2em 0px 0.3em; padding: 0px 0px 0.1em; font-family: arial; color: rgb(0, 0, 0); font-size: 16.7328px;">
    Problems and patterns</h3>
<h2>
    &nbsp;</h2>
<p style="margin: 0px 0px 1.5em; padding: 0px; color: rgb(51, 51, 51); font-family: arial, verdana; font-size: 13.28px; line-height: 19.92px;">
    There are a number of programming challenges which a developer encounters regularly in object-oriented design. There are also widely accepted solutions to these problems. The best known are the design patterns codified by Gamma et al, but in a more general sense the term &quot;design patterns&quot; can be used to refer to any general, repeatable solution to a commonly occurring problem in software design. Some of these commonly occurring problems have implications and solutions particular to object-oriented development.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Gang of Four design patterns</b><br style="margin: 0px; padding: 0px;" />
    Design Patterns: Elements Reusable Object-Oriented Software is an influential book published in 1995 by Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides, sometimes casually called the &quot;Gang of Four.&quot; Along with exploring the capabilities and pitfalls of object-oriented programming, it describes 23 common programming problems and patterns for solving them.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Object-orientation and databases</b><br style="margin: 0px; padding: 0px;" />
    Both object-oriented programming and relational database management systems (RDBMSs) are extremely common in software today. Since relational databases don&#39;t store objects directly (though some RDBMSs have object-oriented features to approximate this), there is a general need to bridge the two worlds. There are a number of widely used solutions to this problem. One of the most common is object-relational mapping, as found in libraries like Java Data Objects, and Ruby on Rails&#39; ActiveRecord.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    There are also object databases which can be used to replace RDBMSs, but these have not been as commercially successful as RDBMSs.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Matching real world</b><br style="margin: 0px; padding: 0px;" />
    OOP can be used to translate from real-world phenomena to program elements (and vice versa). OOP was even invented for the purpose of physical modelling in the Simula-67 programming language. However, not everyone agrees that direct real-world mapping is facilitated by OOP, or is even a worthy goal; Bertrand Meyer argues in Object-Oriented Software Construction that a program is not a model of the world but a model of a model of some part of the world; &quot;Reality is a cousin twice removed&quot;.<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    <b style="margin: 0px; padding: 0px;">Formal definition</b><br style="margin: 0px; padding: 0px;" />
    There have been several attempts at formalizing the concepts used in object-oriented programming. The following concepts and constructs have been used as interpretations of OOP concepts:<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    coalgebraic datatypes&nbsp;<br style="margin: 0px; padding: 0px;" />
    existential quantification and modules&nbsp;<br style="margin: 0px; padding: 0px;" />
    recursion&nbsp;<br style="margin: 0px; padding: 0px;" />
    records and record extensions&nbsp;<br style="margin: 0px; padding: 0px;" />
    F-bounded polymorphism<br style="margin: 0px; padding: 0px;" />
    <br style="margin: 0px; padding: 0px;" />
    Attempts to find a consensus definition or theory behind objects have not proven very successful, and often diverge widely. For example, some definitions focus on mental activities, and some on mere program structuring. One of the simpler definitions is that OOP is the act of using &quot;map&quot; data structures or arrays that can contain functions and pointers to other maps, all with some syntactic and scoping sugar on top. Inheritance can be performed by cloning the maps (sometimes called &quot;prototyping&quot;).</p>
